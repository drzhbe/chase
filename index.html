<html>
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      margin: 0;
    }
    #root {
      height: 100%;
    }
    .box {
      position: absolute;
      box-sizing: border-box;
      transition: all .2s;
    }
  </style>
</head>
<body>
  <canvas id='canvas'></div>
  <script>
    /*
      PowerUps:
      1. SlowMo
      2. Shrink
      3. Reveal dust
      4. Night

      Bosses:
      1. Chase
      2. Invisible
    */
    const r = Math.random;

    class Box {
      constructor({
          canvas,
          borderColor = 'black',
          bgColor,
          w = r() * 200,
          h = r() * 200,
          mx = canvas.clientWidth - w,
          my = canvas.clientHeight - h,
          x = r() * mx,
          y = r() * my,
          border = r() * 5,
          speed = r() * 10,
      }) {
        this.inCollision = false;
        this.borderColor = borderColor;
        this.bgColor = bgColor;
        this.border = border;
        this.mx = mx;
        this.my = my;
        this.w = w;
        this.h = h;
        this.x = x;
        this.y = y;
        this.ox = x;
        this.oy = y;
        this.speed = speed;
      }

      distance(a, b) {
        return (a.x - b.x) ** 2 + (a.y - b.y) ** 2;
      }

      left() { return this.x; }
      right() { return this.x + this.w; }
      top() { return this.y; }
      bottom() { return this.y + this.h; }

      collide(box) {
        return (this.left() < box.right() && this.right() > box.left())
            && (this.top() < box.bottom() && this.bottom() > box.top());
      }
    }

    class Player extends Box {
      swapSides() {
        const w = this.w;
        this.w = this.h;
        this.h = w;
      }

      move(keycode) {
        switch (keycode) {
          case 37: // left
            this.x = Math.max(0, this.x - this.speed);
            break;
          case 38: // up
            this.y = Math.max(0, this.y - this.speed);
            break;
          case 39: // right
            this.x = Math.min(this.mx, this.x + this.speed);
            break;
          case 40: // down
            this.y = Math.min(this.my, this.y + this.speed);
            break;
          default:
            break;
        }
      }
    }

    class Neutral extends Box {
      moveToTarget() {
        const epsilon = 1;
        const distance = this.target ? this.distance(this, this.target) : epsilon + 1;
        if (!this.target || distance < epsilon) {
          this.target = { x: r() * this.mx, y: r() * this.my };
        }
        let { x, y, target } = this;
        let dx = target.x - x;
        dx = dx > 0
            ? Math.min(this.speed, dx)
            : Math.max(-this.speed, dx);
        let dy = target.y - y;
        dy = dy > 0
            ? Math.min(this.speed - dx, dy)
            : Math.max(-(this.speed - dx), dy);
        this.x += dx;
        this.y += dy;
      }
    }

    class Chaser extends Box {
      chase(player) {
        let { x, y } = this;
        let dx = player.x - x;
        dx = dx > 0
            ? Math.min(this.speed, dx)
            : Math.max(-this.speed, dx);
        let dy = player.y - y;
        dy = dy > 0
            ? Math.min(this.speed - dx, dy)
            : Math.max(-(this.speed - dx), dy);
        this.x += dx;
        this.y += dy;
      }
    }

    function addKeyboardEvents(box) {
      window.addEventListener('keydown', e => {
        if (e.keyCode >= 37 && e.keyCode <= 40) {
          box.move(e.keyCode);
        }
        if (e.keyCode === 32) {
          // TODO: fix max values when swapped
          // box.swapSides();
        }
      });
    }

    function update(ctx, player, enemies) {
      enemies.forEach(e => {
        if (e instanceof Neutral) {
          e.moveToTarget();
        } else if (e instanceof Chaser) {
          e.chase(player);
        }
        e.inCollision = false;
      });
      const collider = enemies.find(e => e.collide(player));
      if (collider) {
        collider.inCollision = true;
        player.inCollision = true;
      } else {
        player.inCollision = false;
      }

      ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);

      ctx.lineWidth = player.border;
      ctx.strokeRect(player.x, player.y, player.w, player.h);
      ctx.fillStyle = player.inCollision ? 'lightcoral' : player.bgColor;
      ctx.fillRect(player.x, player.y, player.w, player.h);

      enemies.forEach(e => {
        ctx.lineWidth = e.border;
        ctx.strokeRect(e.x, e.y, e.w, e.h);
        ctx.fillStyle = e.inCollision ? 'lightcoral' : 'transparent';
        ctx.fillRect(e.x, e.y, e.w, e.h);
      });

      requestAnimationFrame(upd);
    }

    const canvas = document.getElementById('canvas');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const ctx = canvas.getContext('2d');
    const player = new Player({ canvas, bgColor: 'lightblue', speed: 50 });
    addKeyboardEvents(player);
    const enemies = Array.from({ length: 10 }).map(_ => new Neutral({ canvas }));
    enemies.push(new Chaser({ canvas }));
    const upd = () => update(ctx, player, enemies);
    upd();
  </script>
</body>
</html>
